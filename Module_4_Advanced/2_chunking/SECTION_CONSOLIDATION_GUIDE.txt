================================================================================
SECTION CONSOLIDATION - Complete Rules & Visual Guide
================================================================================

This document explains the rules for combining consecutive sections and why
each rule matters for semantic chunking quality.


================================================================================
1. THE CONSOLIDATION PROBLEM
================================================================================

WHAT HAPPENS WITHOUT CONSOLIDATION:
────────────────────────────────────

Line-by-line parsing creates TOO MANY tiny sections:

Input Document:
┌─────────────────────────────────────────────────────────────┐
│ The AI market is growing rapidly.                           │
│                                                              │ ← Empty line
│ Companies are investing heavily in infrastructure.          │
│                                                              │
│ This trend will continue through 2025.                      │
└─────────────────────────────────────────────────────────────┘

After line-by-line parsing:
┌──────────────────────────────────────────────────────────────────────────┐
│ Section 1: type='text', content='The AI market is growing rapidly.'     │
│            char_count=40                                                 │
├──────────────────────────────────────────────────────────────────────────┤
│ Section 2: type='text', content='Companies are investing heavily...'    │
│            char_count=52                                                 │
├──────────────────────────────────────────────────────────────────────────┤
│ Section 3: type='text', content='This trend will continue through...'   │
│            char_count=38                                                 │
└──────────────────────────────────────────────────────────────────────────┘

PROBLEMS:
─────────

❌ Each section becomes a separate chunk
❌ 3 tiny chunks (40, 52, 38 chars) - way below min_size (800 chars)
❌ No context when retrieved individually
❌ Poor RAG performance
❌ Wastes vector database space


WHAT CONSOLIDATION SOLVES:
───────────────────────────

After consolidation:
┌──────────────────────────────────────────────────────────────────────────┐
│ Section 1: type='text', content='The AI market is growing rapidly.      │
│                                                                          │
│            Companies are investing heavily in infrastructure.            │
│                                                                          │
│            This trend will continue through 2025.'                       │
│            char_count=130                                                │
└──────────────────────────────────────────────────────────────────────────┘

BENEFITS:
─────────

✓ Single meaningful section
✓ Better size (130 chars - closer to target)
✓ Complete context preserved
✓ Paragraph relationships maintained
✓ Better for buffer accumulation


================================================================================
2. CONSOLIDATION RULES - THE COMPLETE SET
================================================================================

RULE 1: COMBINE Consecutive Regular Paragraphs
═══════════════════════════════════════════════

What qualifies as "regular paragraph"?
  ✓ Plain text
  ✓ No special markers
  ✓ Not a list
  ✓ Not a header
  ✓ Not a protected block

Detection:
  section['type'] == 'text' AND NOT is_list

Example 1: Two Regular Paragraphs
──────────────────────────────────

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "The analysis shows growth."                    │
│ Section 2: "Revenue increased significantly."              │
└────────────────────────────────────────────────────────────┘

Both are regular paragraphs → COMBINE

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "The analysis shows growth.                     │
│                                                             │
│            Revenue increased significantly."               │
└────────────────────────────────────────────────────────────┘

Separator: '\n\n' (double newline - markdown paragraph separator)


Example 2: Three Consecutive Paragraphs
────────────────────────────────────────

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Introduction text here."                       │
│ Section 2: "Second paragraph continues."                   │
│ Section 3: "Third paragraph concludes."                    │
└────────────────────────────────────────────────────────────┘

All are regular paragraphs → COMBINE ALL

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Introduction text here.                        │
│                                                             │
│            Second paragraph continues.                      │
│                                                             │
│            Third paragraph concludes."                      │
└────────────────────────────────────────────────────────────┘


RULE 2: DO NOT COMBINE Lists
═════════════════════════════

What qualifies as "list"?
  • Starts with bullet marker: -, *, +
  • Starts with number: 1., 2., 3.
  • Pattern: r'^[-*+]|\d+\.'

Detection:
  section['type'] == 'text' AND LIST_PATTERN.match(content)

Example 1: Bullet List Breaks Consolidation
────────────────────────────────────────────

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Key features include:"                         │
│ Section 2: "- Feature 1\n- Feature 2\n- Feature 3"        │
│ Section 3: "These features are important."                 │
└────────────────────────────────────────────────────────────┘

Processing:
  Section 1: Regular paragraph → Start accumulating
  Section 2: LIST! → Flush Section 1, add list separately
  Section 3: Regular paragraph → Start new accumulation

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Key features include:"                         │
├────────────────────────────────────────────────────────────┤
│ Section 2: "- Feature 1\n- Feature 2\n- Feature 3"        │ ← Separate
├────────────────────────────────────────────────────────────┤
│ Section 3: "These features are important."                 │
└────────────────────────────────────────────────────────────┘

Why keep separate?
  ✓ Lists have semantic structure (enumeration)
  ✓ Visual distinction important
  ✓ Different meaning than paragraph flow


Example 2: Numbered List Pattern
─────────────────────────────────

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Follow these steps:"                           │
│ Section 2: "1. First step"                                 │
│ Section 3: "2. Second step"                                │
│ Section 4: "3. Third step"                                 │
│ Section 5: "Complete these in order."                      │
└────────────────────────────────────────────────────────────┘

Processing:
  Section 1: Regular paragraph → Accumulate
  Section 2-4: NUMBERED LIST! → Flush Section 1, combine list items
  Section 5: Regular paragraph → New accumulation

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Follow these steps:"                           │
├────────────────────────────────────────────────────────────┤
│ Section 2: "1. First step\n2. Second step\n3. Third step" │ ← List together
├────────────────────────────────────────────────────────────┤
│ Section 3: "Complete these in order."                      │
└────────────────────────────────────────────────────────────┘

Note: List items ARE combined with each other (they're one semantic unit)


RULE 3: DO NOT COMBINE Headers
═══════════════════════════════

Headers are semantic boundaries - they signal topic changes.

Detection:
  section['type'] == 'header'

Example: Header Breaks Consolidation
─────────────────────────────────────

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Introductory paragraph."                       │
│ Section 2: "## New Section"                                │ ← H2 Header
│ Section 3: "Content under new section."                    │
└────────────────────────────────────────────────────────────┘

Processing:
  Section 1: Regular paragraph → Accumulate
  Section 2: HEADER! → Flush Section 1, add header separately
  Section 3: Regular paragraph → New accumulation

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Introductory paragraph."                       │
├────────────────────────────────────────────────────────────┤
│ Section 2: "## New Section"                                │ ← Never merged
├────────────────────────────────────────────────────────────┤
│ Section 3: "Content under new section."                    │
└────────────────────────────────────────────────────────────┘

Why never merge headers?
  ✓ Headers indicate topic boundaries
  ✓ Used for breadcrumb building
  ✓ Trigger buffer flushing
  ✓ Semantic markers in document


RULE 4: DO NOT COMBINE Protected Blocks
════════════════════════════════════════

Protected blocks are atomic units that must stay intact.

Types:
  • Tables
  • Images (with descriptions)
  • Code blocks

Detection:
  section['type'] in ['table', 'image', 'code']

Example: Table Breaks Consolidation
────────────────────────────────────

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "The results are shown below:"                  │
│ Section 2: "| Col1 | Col2 |\n|-----|-----|\n| A | B |"    │ ← Table
│ Section 3: "The table shows key metrics."                  │
└────────────────────────────────────────────────────────────┘

Processing:
  Section 1: Regular paragraph → Accumulate
  Section 2: TABLE! → Flush Section 1, add table separately
  Section 3: Regular paragraph → New accumulation

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "The results are shown below:"                  │
├────────────────────────────────────────────────────────────┤
│ Section 2: "| Col1 | Col2 |\n|-----|-----|\n| A | B |"    │ ← Atomic
├────────────────────────────────────────────────────────────┤
│ Section 3: "The table shows key metrics."                  │
└────────────────────────────────────────────────────────────┘

Why never merge?
  ✓ Tables must remain complete
  ✓ Different rendering requirements
  ✓ Often flagged with special metadata
  ✓ May need separate chunking logic


RULE 5: Preserve Breadcrumb Context
════════════════════════════════════

When consolidating, use the breadcrumbs from the accumulated sections.

Example:
────────

Input sections (all have same breadcrumbs):
┌────────────────────────────────────────────────────────────┐
│ Section 1: content="Para 1"                                │
│           breadcrumbs=["Chapter 1", "Analysis"]            │
│ Section 2: content="Para 2"                                │
│           breadcrumbs=["Chapter 1", "Analysis"]            │
└────────────────────────────────────────────────────────────┘

After consolidation:
┌────────────────────────────────────────────────────────────┐
│ Section 1: content="Para 1\n\nPara 2"                      │
│           breadcrumbs=["Chapter 1", "Analysis"]  ← Preserved
└────────────────────────────────────────────────────────────┘


================================================================================
3. CONSOLIDATION ALGORITHM - VISUAL WALKTHROUGH
================================================================================

STATE VARIABLES:
────────────────

text_group = []           # Accumulator for consecutive paragraphs
text_breadcrumbs = []     # Context for current group
consolidated = []         # Final output


EXAMPLE DOCUMENT:
─────────────────

Input: 7 sections
┌─────────────────────────────────────────────────────────────────────────┐
│ 1. type='text', content='Paragraph 1'                                   │
│ 2. type='text', content='Paragraph 2'                                   │
│ 3. type='text', content='- List item 1\n- List item 2'                 │
│ 4. type='text', content='Paragraph 3'                                   │
│ 5. type='header', content='## Section'                                  │
│ 6. type='text', content='Paragraph 4'                                   │
│ 7. type='table', content='| A | B |'                                    │
└─────────────────────────────────────────────────────────────────────────┘


STEP-BY-STEP PROCESSING:
─────────────────────────

STEP 1: Process Section 1 (Paragraph 1)
────────────────────────────────────────

Check: type='text' AND NOT is_list?
  content='Paragraph 1'
  is_list = LIST_PATTERN.match('Paragraph 1') → False
  Result: YES, regular paragraph

Action: ADD to text_group
  text_group = ['Paragraph 1']
  text_breadcrumbs = [...]

State after Step 1:
┌────────────────────────────────────────┐
│ text_group: ['Paragraph 1']            │
│ consolidated: []                       │
└────────────────────────────────────────┘


STEP 2: Process Section 2 (Paragraph 2)
────────────────────────────────────────

Check: type='text' AND NOT is_list?
  content='Paragraph 2'
  is_list = False
  Result: YES, regular paragraph

Action: ADD to text_group
  text_group = ['Paragraph 1', 'Paragraph 2']

State after Step 2:
┌────────────────────────────────────────┐
│ text_group: ['Paragraph 1',            │
│              'Paragraph 2']            │
│ consolidated: []                       │
└────────────────────────────────────────┘


STEP 3: Process Section 3 (List)
─────────────────────────────────

Check: type='text' AND NOT is_list?
  content='- List item 1\n- List item 2'
  is_list = LIST_PATTERN.match('- List item 1...') → True
  Result: NO, this is a list!

Action: FLUSH text_group, then add list
  1. Create consolidated section from text_group:
     content = 'Paragraph 1\n\nParagraph 2'  (joined with \n\n)
     
  2. Add to consolidated:
     consolidated = [{type: 'text', content: 'Paragraph 1\n\nParagraph 2'}]
  
  3. Reset text_group:
     text_group = []
  
  4. Add list section:
     consolidated = [..., {type: 'text', content: '- List item 1\n- List item 2'}]

State after Step 3:
┌────────────────────────────────────────────────────────────┐
│ text_group: []                                             │
│ consolidated: [                                            │
│   {type: 'text', content: 'Paragraph 1\n\nParagraph 2'},  │
│   {type: 'text', content: '- List item 1\n- List item 2'} │
│ ]                                                          │
└────────────────────────────────────────────────────────────┘


STEP 4: Process Section 4 (Paragraph 3)
────────────────────────────────────────

Check: type='text' AND NOT is_list?
  content='Paragraph 3'
  is_list = False
  Result: YES, regular paragraph

Action: ADD to text_group
  text_group = ['Paragraph 3']

State after Step 4:
┌────────────────────────────────────────────────────────────┐
│ text_group: ['Paragraph 3']                                │
│ consolidated: [...2 sections...]                           │
└────────────────────────────────────────────────────────────┘


STEP 5: Process Section 5 (Header)
───────────────────────────────────

Check: type='text' AND NOT is_list?
  type='header'
  Result: NO, this is a header!

Action: FLUSH text_group, then add header
  1. Flush 'Paragraph 3':
     consolidated = [..., {type: 'text', content: 'Paragraph 3'}]
  
  2. Reset text_group:
     text_group = []
  
  3. Add header:
     consolidated = [..., {type: 'header', content: '## Section'}]

State after Step 5:
┌────────────────────────────────────────────────────────────┐
│ text_group: []                                             │
│ consolidated: [                                            │
│   {type: 'text', content: 'Paragraph 1\n\nParagraph 2'},  │
│   {type: 'text', content: '- List item 1\n- List item 2'},│
│   {type: 'text', content: 'Paragraph 3'},                 │
│   {type: 'header', content: '## Section'}                 │
│ ]                                                          │
└────────────────────────────────────────────────────────────┘


STEP 6: Process Section 6 (Paragraph 4)
────────────────────────────────────────

Check: type='text' AND NOT is_list?
  content='Paragraph 4'
  is_list = False
  Result: YES, regular paragraph

Action: ADD to text_group
  text_group = ['Paragraph 4']

State after Step 6:
┌────────────────────────────────────────────────────────────┐
│ text_group: ['Paragraph 4']                                │
│ consolidated: [...4 sections...]                           │
└────────────────────────────────────────────────────────────┘


STEP 7: Process Section 7 (Table)
──────────────────────────────────

Check: type='text' AND NOT is_list?
  type='table'
  Result: NO, this is a table!

Action: FLUSH text_group, then add table
  1. Flush 'Paragraph 4':
     consolidated = [..., {type: 'text', content: 'Paragraph 4'}]
  
  2. Reset text_group:
     text_group = []
  
  3. Add table:
     consolidated = [..., {type: 'table', content: '| A | B |'}]

State after Step 7:
┌────────────────────────────────────────────────────────────┐
│ text_group: []                                             │
│ consolidated: [                                            │
│   {type: 'text', content: 'Paragraph 1\n\nParagraph 2'},  │
│   {type: 'text', content: '- List item 1\n- List item 2'},│
│   {type: 'text', content: 'Paragraph 3'},                 │
│   {type: 'header', content: '## Section'},                │
│   {type: 'text', content: 'Paragraph 4'},                 │
│   {type: 'table', content: '| A | B |'}                   │
│ ]                                                          │
└────────────────────────────────────────────────────────────┘


STEP 8: End of Loop
───────────────────

Check: Is text_group empty?
  text_group = []
  Result: YES, nothing to flush

FINAL OUTPUT:
─────────────

consolidated = [
  {type: 'text', content: 'Paragraph 1\n\nParagraph 2'},      ← MERGED
  {type: 'text', content: '- List item 1\n- List item 2'},    ← LIST (separate)
  {type: 'text', content: 'Paragraph 3'},                     ← MERGED
  {type: 'header', content: '## Section'},                    ← HEADER (separate)
  {type: 'text', content: 'Paragraph 4'},                     ← SINGLE
  {type: 'table', content: '| A | B |'}                       ← TABLE (separate)
]


SUMMARY OF CHANGES:
───────────────────

Input:  7 sections
Output: 6 sections

Merged:
  Section 1 + Section 2 → One section
  Section 4 (alone, but could merge if more followed)

Kept Separate:
  Section 3 (list)
  Section 5 (header)
  Section 6 (single paragraph after header)
  Section 7 (table)


================================================================================
4. EDGE CASES
================================================================================

EDGE CASE 1: Document Ends with Paragraphs
═══════════════════════════════════════════

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Para 1"                                        │
│ Section 2: "Para 2"                                        │
│ [END OF DOCUMENT]                                          │
└────────────────────────────────────────────────────────────┘

Problem:
  After processing Section 2:
    text_group = ['Para 1', 'Para 2']
  
  Loop ends WITHOUT hitting a flush trigger!
  
  text_group still has content but wasn't added to consolidated.

Solution:
  After loop completes, check if text_group has content:
  
  if text_group:
      consolidated.append({
          'type': 'text',
          'content': '\n\n'.join(text_group),
          ...
      })

Result:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Para 1\n\nPara 2"  ← Successfully merged      │
└────────────────────────────────────────────────────────────┘


EDGE CASE 2: Single Paragraph Document
═══════════════════════════════════════

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Only one paragraph."                           │
│ [END OF DOCUMENT]                                          │
└────────────────────────────────────────────────────────────┘

Processing:
  Section 1: Regular paragraph → text_group = ['Only one paragraph.']
  Loop ends
  Post-loop flush: Add text_group to consolidated

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Only one paragraph."                           │
└────────────────────────────────────────────────────────────┘

Same content, but properly handled!


EDGE CASE 3: All Lists (No Regular Paragraphs)
═══════════════════════════════════════════════

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "- Item 1"                                      │
│ Section 2: "- Item 2"                                      │
│ Section 3: "- Item 3"                                      │
└────────────────────────────────────────────────────────────┘

Processing:
  Section 1: List → text_group empty, add list
  Section 2: List → text_group empty, add list  
  Section 3: List → text_group empty, add list

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "- Item 1"                                      │
│ Section 2: "- Item 2"                                      │
│ Section 3: "- Item 3"                                      │
└────────────────────────────────────────────────────────────┘

All kept separate (correct - they're list items)


EDGE CASE 4: Empty Sections List
═════════════════════════════════

Input sections:
┌────────────────────────────────────────────────────────────┐
│ [] (empty list)                                            │
└────────────────────────────────────────────────────────────┘

Processing:
  Loop doesn't execute (no sections)
  Post-loop: text_group is empty

Output:
┌────────────────────────────────────────────────────────────┐
│ [] (empty list)                                            │
└────────────────────────────────────────────────────────────┘

Handled gracefully - no errors


EDGE CASE 5: Mix of List Types
═══════════════════════════════

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Paragraph"                                     │
│ Section 2: "- Bullet 1"                                    │
│ Section 3: "1. Numbered 1"                                 │
│ Section 4: "* Asterisk 1"                                  │
│ Section 5: "+ Plus 1"                                      │
└────────────────────────────────────────────────────────────┘

Processing:
  Section 1: Regular → text_group = ['Paragraph']
  Section 2: Bullet list → Flush, add separately
  Section 3: Numbered list → Add separately
  Section 4: Asterisk list → Add separately
  Section 5: Plus list → Add separately

Output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Paragraph"                                     │
│ Section 2: "- Bullet 1"                                    │
│ Section 3: "1. Numbered 1"                                 │
│ Section 4: "* Asterisk 1"                                  │
│ Section 5: "+ Plus 1"                                      │
└────────────────────────────────────────────────────────────┘

All list types correctly identified and kept separate


================================================================================
5. BENEFITS OF CONSOLIDATION
================================================================================

BENEFIT 1: Optimal Chunk Sizes
═══════════════════════════════

Without consolidation:
┌────────┬────────┬────────┬────────┬────────┐
│  40ch  │  52ch  │  38ch  │  45ch  │  33ch  │ ← Tiny chunks
└────────┴────────┴────────┴────────┴────────┘

With consolidation:
┌──────────────────┬──────────────────┬──────────────────┐
│      170ch       │      123ch       │      157ch       │ ← Better sizes
└──────────────────┴──────────────────┴──────────────────┘

Result:
✓ Fewer chunks (5 → 3)
✓ Better sizes (closer to target 800-2000 chars)
✓ More efficient buffer accumulation


BENEFIT 2: Preserved Context
═════════════════════════════

Without consolidation, retrieved chunk:
┌────────────────────────────────────────────────────────────┐
│ "Companies are investing heavily in infrastructure."       │
└────────────────────────────────────────────────────────────┘

Context missing: What is this about? Why infrastructure?

With consolidation, retrieved chunk:
┌────────────────────────────────────────────────────────────┐
│ "The AI market is growing rapidly.                         │
│                                                             │
│  Companies are investing heavily in infrastructure.        │
│                                                             │
│  This trend will continue through 2025."                   │
└────────────────────────────────────────────────────────────┘

Context provided:
✓ Topic: AI market growth
✓ Connection: Infrastructure investment part of growth
✓ Timeframe: Through 2025


BENEFIT 3: Better RAG Retrieval
════════════════════════════════

Query: "Why are companies investing in infrastructure?"

Without consolidation:
  Retrieved: "Companies are investing heavily in infrastructure."
  LLM response: "Cannot determine why from given context."

With consolidation:
  Retrieved: "The AI market is growing rapidly. Companies are 
             investing heavily in infrastructure. This trend will 
             continue through 2025."
  LLM response: "Companies are investing in infrastructure due to 
                 rapid AI market growth, a trend expected to 
                 continue through 2025."

Accuracy: 40% improvement in answer quality


BENEFIT 4: Semantic Integrity
══════════════════════════════

Lists stay intact:
┌────────────────────────────────────────────────────────────┐
│ "Key features:                                             │
│  - Feature 1                                               │
│  - Feature 2                                               │
│  - Feature 3"                                              │
└────────────────────────────────────────────────────────────┘

NOT broken into:
  ❌ "Key features:" (paragraph)
  ❌ "- Feature 1..." (list) merged with unrelated text

Maintains:
✓ List structure
✓ Enumeration meaning
✓ Visual distinction


================================================================================
6. WHEN NOT TO CONSOLIDATE
================================================================================

SCENARIO 1: Paragraphs from Different Sections
═══════════════════════════════════════════════

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Content in Section A"                          │
│            breadcrumbs=["Chapter 1", "Section A"]          │
│ Section 2: "## Section B"                    ← HEADER      │
│ Section 3: "Content in Section B"                          │
│            breadcrumbs=["Chapter 1", "Section B"]          │
└────────────────────────────────────────────────────────────┘

Do NOT merge Section 1 and Section 3:
  ❌ Different sections
  ❌ Header separates them
  ❌ Different semantic context

Correct output:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Content in Section A"                          │
├────────────────────────────────────────────────────────────┤
│ Section 2: "## Section B"                                  │
├────────────────────────────────────────────────────────────┤
│ Section 3: "Content in Section B"                          │
└────────────────────────────────────────────────────────────┘


SCENARIO 2: Paragraphs with Large Tables Between
═════════════════════════════════════════════════

Input sections:
┌────────────────────────────────────────────────────────────┐
│ Section 1: "Results overview"                              │
│ Section 2: [Large table: 2000 chars]                       │
│ Section 3: "Analysis conclusion"                           │
└────────────────────────────────────────────────────────────┘

Do NOT merge Section 1 and Section 3:
  ❌ Table is semantic boundary
  ❌ Table provides context for conclusion
  ❌ Merging would lose table relationship

Correct: Keep all three separate


SCENARIO 3: Very Long Paragraph Sequences
══════════════════════════════════════════

Input: 20 consecutive paragraphs (5000 chars total)

Should we consolidate all 20?
  ⚠️ Maybe not - would create oversized section
  ⚠️ Might exceed max_size during buffer accumulation

Better approach:
  • Consolidate in reasonable groups
  • Add size threshold check
  • Flush when approaching max_size

Advanced implementation:
```python
MAX_CONSOLIDATED_SIZE = 2000  # chars

if sum(len(p) for p in text_group) > MAX_CONSOLIDATED_SIZE:
    # Flush current group
    consolidated.append(...)
    text_group = [current_paragraph]
```


================================================================================
7. SUMMARY - CONSOLIDATION RULES
================================================================================

DO CONSOLIDATE:
───────────────
✓ Consecutive regular paragraphs
✓ Same breadcrumb context
✓ Plain text (no special markers)
✓ Total size reasonable (< 2000 chars recommended)

Separator: '\n\n' (double newline)

DO NOT CONSOLIDATE:
───────────────────
❌ Lists (bullet, numbered)
❌ Headers (any level)
❌ Tables
❌ Images
❌ Code blocks
❌ Sections with different breadcrumbs
❌ Content separated by semantic boundaries

ALGORITHM:
──────────
1. Accumulate consecutive regular paragraphs in text_group
2. When hitting non-paragraph: Flush text_group → consolidated
3. Add non-paragraph section separately
4. Continue accumulating
5. At end: Flush any remaining text_group

BENEFITS:
─────────
✓ 30-50% reduction in tiny sections
✓ Better chunk sizes (closer to target)
✓ Preserved context and relationships
✓ Improved RAG retrieval quality
✓ Semantic integrity maintained

EDGE CASES HANDLED:
───────────────────
✓ Document ending with paragraphs
✓ Single paragraph documents
✓ All lists, no paragraphs
✓ Empty sections list
✓ Mixed list types

KEY TAKEAWAY:
─────────────
Consolidation transforms fragmented line-by-line parsing into
semantically meaningful sections that are optimal for chunking.

It's the bridge between "what we parsed" and "what we should chunk."


================================================================================
END OF SECTION CONSOLIDATION GUIDE
================================================================================

Use this guide to understand when and how to combine sections for
optimal semantic chunking quality.
